{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to EngineCPP The EngineCPP is a personal project created as a way to improve my understanding of : Manual manipulation of cpu and gpu memory. Understanding 3D graphics api. For an overview of the engine architecture see architecture overview . Modules Internal modules that makes up the engine. Front-end modules that runs atop an engine instance. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to EngineCPP"},{"location":"#welcome-to-enginecpp","text":"The EngineCPP is a personal project created as a way to improve my understanding of : Manual manipulation of cpu and gpu memory. Understanding 3D graphics api. For an overview of the engine architecture see architecture overview .","title":"Welcome to EngineCPP"},{"location":"#modules","text":"Internal modules that makes up the engine. Front-end modules that runs atop an engine instance.","title":"Modules"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"architecture_overview/","text":"The philosophy of the engine The execution flow of the engine can be seen as a succession of shader pass execution. For example, let's say that the engine needs to allocate some render objects. What the engine does is reading a buffer where is stored all events of allocation and execute them all before continuing exectuion. The whole engine comes together by chaining multiple execution passes in the right order in order to draw a frame. Execution graph Here is the engine chain of execution represented as a graph: Main loop The main loop is composed of execution units. Execution units are step that trigger all dependant execution block in the order defined by the dependencies. For exemple, we can see that the Render system is updated when the following execution units are completed : Render allocation, Render middleware and the GPU buffer step. Some execution unit within the main loop are called \"user logic\". These execution units are hooks that the engine user can hook on to execute custom logic at this specific point. Custom logic execution units are likely to create node, add component or move node. Thus, we must be sure that all scene middleware steps are called before the scene tree events are cleaned. Scene An Engine instance is associated to a unique Scene. The Scene is a hierachical collection of Nodes located in 3D space. Every nodes can have multiple components attached to them. These components act as a link between the user and the internal systems. ( scene ) Allocations The allocation steps act as an interface for allocating system objects. Allocations input can either be provided directly by the user or by requesting the asset database. ( ressource ) Scene middleware Scene middlewares are where node component ressources are stored. They act as the communication layer between the scene and the internal systems. Because nodes can move in 3D space. The state of the Node is updated when it's position, rotation or scale has changed. The Scene Middlewares are the consumers of this state. When a Node has moved, they send events to internal systems to take this change into account. ( scene middleware ). Interaction with user If we want to make a node display a 3D mesh, the user must : Allocate a Node and set it's 3D coordinates. Allocate a mesh renderer component ressource from the render middleware. Add a component to the Node and link it with the mesh renderer token. Asset management All assets (3DModels, textures, user defined assets...) are stored in a unique local database. Asset files are written either in a human readable format (.json, .obj, ...) or compressed (.png). However, when stored in the database, they are compiled into a blob that allows the engine to map it to internal objects with little efforts. This compilation is done during the build process, so we eliminate the runtime overhead of loading and decoding file formats. ( asset database )","title":"Architecture Overview"},{"location":"architecture_overview/#the-philosophy-of-the-engine","text":"The execution flow of the engine can be seen as a succession of shader pass execution. For example, let's say that the engine needs to allocate some render objects. What the engine does is reading a buffer where is stored all events of allocation and execute them all before continuing exectuion. The whole engine comes together by chaining multiple execution passes in the right order in order to draw a frame.","title":"The philosophy of the engine"},{"location":"architecture_overview/#execution-graph","text":"Here is the engine chain of execution represented as a graph:","title":"Execution graph"},{"location":"architecture_overview/#main-loop","text":"The main loop is composed of execution units. Execution units are step that trigger all dependant execution block in the order defined by the dependencies. For exemple, we can see that the Render system is updated when the following execution units are completed : Render allocation, Render middleware and the GPU buffer step. Some execution unit within the main loop are called \"user logic\". These execution units are hooks that the engine user can hook on to execute custom logic at this specific point. Custom logic execution units are likely to create node, add component or move node. Thus, we must be sure that all scene middleware steps are called before the scene tree events are cleaned.","title":"Main loop"},{"location":"architecture_overview/#scene","text":"An Engine instance is associated to a unique Scene. The Scene is a hierachical collection of Nodes located in 3D space. Every nodes can have multiple components attached to them. These components act as a link between the user and the internal systems. ( scene )","title":"Scene"},{"location":"architecture_overview/#allocations","text":"The allocation steps act as an interface for allocating system objects. Allocations input can either be provided directly by the user or by requesting the asset database. ( ressource )","title":"Allocations"},{"location":"architecture_overview/#scene-middleware","text":"Scene middlewares are where node component ressources are stored. They act as the communication layer between the scene and the internal systems. Because nodes can move in 3D space. The state of the Node is updated when it's position, rotation or scale has changed. The Scene Middlewares are the consumers of this state. When a Node has moved, they send events to internal systems to take this change into account. ( scene middleware ).","title":"Scene middleware"},{"location":"architecture_overview/#interaction-with-user","text":"If we want to make a node display a 3D mesh, the user must : Allocate a Node and set it's 3D coordinates. Allocate a mesh renderer component ressource from the render middleware. Add a component to the Node and link it with the mesh renderer token.","title":"Interaction with user"},{"location":"architecture_overview/#asset-management","text":"All assets (3DModels, textures, user defined assets...) are stored in a unique local database. Asset files are written either in a human readable format (.json, .obj, ...) or compressed (.png). However, when stored in the database, they are compiled into a blob that allows the engine to map it to internal objects with little efforts. This compilation is done during the build process, so we eliminate the runtime overhead of loading and decoding file formats. ( asset database )","title":"Asset management"},{"location":"asset_database/","text":"Asset database The asset database is a database that stores : Engine assets as blob from human readable format Engine assets dependencies Engine assets file metadata (compilation only, never requested by the engine) All assets are identified by a unique id that is the hash code of the local path of the asset file. For example, if we specify at database compilation time that the asset root is \"E:/document/project/assets/\" then an asset file located at \"E:/document/project/assets/model/test.obj\" will be stored and requested by using \"model/test.obj\" as input for hash calculation. Hashes are calculated by using the djp2 function ( hash ). Engine assets Engine assets are stored as a blob chunk. The goal of the database is to provide an object format that needs the least amount of calculation for the engine to interpret it. So assets files are transformed from a human readable format (or commonly used file extensions like .png, .obj) to one that is close to the engine object. For exemple, if we want to store an array of integers, the json array : { \"array\":[0,1,2,3,4,5] } will be compiled to it's packed memory representation : [size] (size_t 8 bytes) [0] (int 4 bytes) [1] (int 4 bytes) [2] (int 4 bytes) [3] (int 4 bytes) [4] (int 4 bytes) All custom defined asset files are written in json. The first field of every json file must be the type of the asset file. For exemple, if we define a material, the json file will start with : { \"type\": \"MATERIAL\", ... } Engine asset dependencies Asset dependencies are used to idicate all assets that are mentionned by the current asset. The system of compilation to blob is exactly the same as assets. The difference is that we are compiling the asset to provide a list of dependant asset ids. Asset dependencies can be recursively evaluated, it is up the asset compilation implementation to decide it. Again, the goal is to be the most efficient possible when dependencies are read by the engine. The assets dependencies have their own table because : We don't always request them, because we have already requested an asset dependency that have been evaluated recursively. In the future, we can have a case where we want to request dependies in different format for the same asset. Engine asset metadata Asset metadata are all data that are irrelevant to the engine and only used or updated by tools. Asset compilation The asset compilation is the program executed to transform human readable assets to engine assets. The program takes an asset configuration json file that lists all assets that are going to be compiled. All assets path mentionned are relative to the asset folder root. The asset compilation configuration can be used to compile multiple asset databases. This is useful when writing test cases for example. The configuration file has a \"common\" section that is used to compile asset that are required for the engine to startup. The required assets will be compiled for all database.","title":"AssetDatabase"},{"location":"asset_database/#asset-database","text":"The asset database is a database that stores : Engine assets as blob from human readable format Engine assets dependencies Engine assets file metadata (compilation only, never requested by the engine) All assets are identified by a unique id that is the hash code of the local path of the asset file. For example, if we specify at database compilation time that the asset root is \"E:/document/project/assets/\" then an asset file located at \"E:/document/project/assets/model/test.obj\" will be stored and requested by using \"model/test.obj\" as input for hash calculation. Hashes are calculated by using the djp2 function ( hash ).","title":"Asset database"},{"location":"asset_database/#engine-assets","text":"Engine assets are stored as a blob chunk. The goal of the database is to provide an object format that needs the least amount of calculation for the engine to interpret it. So assets files are transformed from a human readable format (or commonly used file extensions like .png, .obj) to one that is close to the engine object. For exemple, if we want to store an array of integers, the json array : { \"array\":[0,1,2,3,4,5] } will be compiled to it's packed memory representation : [size] (size_t 8 bytes) [0] (int 4 bytes) [1] (int 4 bytes) [2] (int 4 bytes) [3] (int 4 bytes) [4] (int 4 bytes) All custom defined asset files are written in json. The first field of every json file must be the type of the asset file. For exemple, if we define a material, the json file will start with : { \"type\": \"MATERIAL\", ... }","title":"Engine assets"},{"location":"asset_database/#engine-asset-dependencies","text":"Asset dependencies are used to idicate all assets that are mentionned by the current asset. The system of compilation to blob is exactly the same as assets. The difference is that we are compiling the asset to provide a list of dependant asset ids. Asset dependencies can be recursively evaluated, it is up the asset compilation implementation to decide it. Again, the goal is to be the most efficient possible when dependencies are read by the engine. The assets dependencies have their own table because : We don't always request them, because we have already requested an asset dependency that have been evaluated recursively. In the future, we can have a case where we want to request dependies in different format for the same asset.","title":"Engine asset dependencies"},{"location":"asset_database/#engine-asset-metadata","text":"Asset metadata are all data that are irrelevant to the engine and only used or updated by tools.","title":"Engine asset metadata"},{"location":"asset_database/#asset-compilation","text":"The asset compilation is the program executed to transform human readable assets to engine assets. The program takes an asset configuration json file that lists all assets that are going to be compiled. All assets path mentionned are relative to the asset folder root. The asset compilation configuration can be used to compile multiple asset databases. This is useful when writing test cases for example. The configuration file has a \"common\" section that is used to compile asset that are required for the engine to startup. The required assets will be compiled for all database.","title":"Asset compilation"},{"location":"gpu/","text":"The GPU module is responsible of : Providing convenvient systems to allocate, free and write to GPU memory chunks. Deferring commands that needs synchronization with the gpu. Abstracting graphics objects such as Shader, Material ... Architecture The GPU module is composed of : GPUHeap : allocates huge chunk of GPU memory and cut slice into it based on vulkan constraint. BufferAllocator : allocates and holds token of vulkan buffer objects. BufferEvents : stores all GPU operations that are deferred to be executed on a command buffer. BufferMemory : acts as an entry point for memory allocation and read/write event push. GraphicsHeap : stores token of graphics objects. GraphicsAllocator : allocates abstracted graphics objects. GraphicsBinder : uses graphics objects to execute draw commands. On initialisation, the GPU systems creates two command buffer objects that are responsible of oredring the GPU to execute draw operations or buffer copy operations. Before the start of the frame, these command buffers are flushed from previous commands. At the end of the frame, these command buffers are submitted in the following order : Transfer command buffer : responsible for buffer copy operations and texture layout transition. Graphics command buffer : responsible for binding graphics objects and draw vertices. GPU memory allocation The GPU memory allocation is done by allocating one or more huge chunks of memory on the GPU. Any GPU allocation or deallocation works with a slice of memory of the huge chunk. Memory requirements such as size and alignment is provided by the vulkan API. From these constraint, we manually identify and cut a slice of memory from the GPUHeap. Every heap has it's own memory type defined by the the types of memory requested. Buffer A Buffer is a general purpose memory (like if you allocate memory from CPU). A buffer can be of two type : _Host means that the memory pointer can be directly mapped and visible from CPU. The memory is still allocated on the GPU but reading from it may be less efficient. _GPU means that the memory pointer cannot be visible from CPU. In order to read/write to it, we must create a temporary Host buffer and execute command to transfer data from/to the GPU. All buffer allocations are instant. Ask vulkan for memory requirements. Cut a memory from an already allocated buffer. BufferHost read/write are instantaneous because their memory type corresponds to a host heap chunk that has already been mapped. BufferGPU read/write have an additional level of indirection as a temporary Host buffer must be created and a gpu operation must be registered to a command buffer. Image An Image is allocated the same way as a Buffer. Instead of passing a size in bytes, we use an image format object. struct ImageFormat { VkImageAspectFlags imageAspect; VkImageType imageType; ImageUsageFlag imageUsage; VkFormat format; v3ui extent; uint32 mipLevels; uint32 arrayLayers; VkSampleCountFlagBits samples; }; WARNING : mipLevels and arrayLayers are not supported yet. The vulkan api let the user manage an internal state of an image called ImageLayout. It acts as a flag to indicates what operations are allowed on the image. The imageUsage flag indicates where this image will be used (as a shader parameter, or as the target of a render pass) . This flags is the only parameter used to set the underlying image layout. Because the vulkan API needs a specific ImageLayout value when the image is being read or written to, every operations on image must be deferred to execute layout transition before and after. BufferEvents step The BufferEvents stores all deferred GPU buffer read/write and texture copy events. These events are consumed and the beginning of a frame by the transfer command buffer. Events are consumed in the following order : Image allocation event to execute image layout transition to it's target layout. Read/Write to BufferGPU. Read/Write to ImageGPU. WARNING : It is very important that image host and gpu allocation events are processed before image copy operations because further events assume that the image layout of the image is the targetted one. Image allocation When an image is allocated, it's image layout is undefined. This events execute image layout transition based on the image imageUsage. ImageLayout transition from unknown state to desired imageUsage. Read/Write to BufferGPU Push copy commands to the temporary buffer (as decribed in the buffer section ) Read/Write to ImageGPU ImageLayout transition from desired imageUsage to transfert_src or transfert_dst depending on the operation. Copy command. ImageLayout transition from transfert_src or transfert_dst to desired imageUsage. Graphics abstraction All graphics abstraction objects describe how a draw command is performed. Allocation of any graphics object is done by having a reference to the BufferMemory object because they can cause buffer or image allocation. Graphics abstraction is a layer on top of the GPU memory layer. There is no depedencies between all these objects. This choice has been made to not enforce any hierarchy. The dependency between objects is ensured by the GraphicsBinding. TextureGPU: A TextureGPU is an Image with a description of which mip map or arraylayer is selected. GraphicsPass: The GraphicsPass is the render texture attachments that will be used for drawing. Texture attachment supported are color attachment and depth attachment. Shader: A Shader is a program that is executed against a GraphicsPass and a set of ShaderParameters. On allocation, a shader is configured to decide wether ztest and zwrite is perfored. ShaderModule: A ShaderModule is the compiled small unit of (vertex|fragment) shader pass executed by the Shader. ShaderLayout: The ShaderLayout indicate the format of all parameters of the Shader (including vertex format). It can be seen as the Reflection data of a Shader. ShaderParameter: A ShaderParameter is a buffer or image that is binded at a certain location of the shader to be used by the program. ShaderParameters can be UniformHost, UniformGPU or TextureGPU. Material: A Material is an array of ShaderParameters. Graphics binding The graphics binding object allows to notify to the GPU all data needed to perform a draw call. Binding draw commands are sended to the graphics command buffer. A specific bindind order must be respected as validation is performed for every binding. Once an object has been binded, it will still be binded until another one takes it's place. This means that we don't have to re-bind the GraphicsPass or the Shader when we bind another set of ShaderParameters. ShaderParameters can be binded at any position, they also stay binded at the desired index until another one takes place. Presentation The presentation is a direct usage of the GraphicsBinding. The presentation layer consists of a SwapChain render the input render texture to a present texture. Present textures are allocated internally by the vulkan API by providing a native handle of the window. The SwapChain allocates all GraphicsObjects necessary for drawing the render texture to a present texture. The presentation module is optional, it is up to the consumer to decide whether or not to allocate one and include it the the GraphicsBinding loop. Input : Compiled image quad blit shader module. Already allocated render texture. Window resize event When the native window is resized internal present textures are reallocated to fit the window dimensions.","title":"GPU"},{"location":"gpu/#architecture","text":"The GPU module is composed of : GPUHeap : allocates huge chunk of GPU memory and cut slice into it based on vulkan constraint. BufferAllocator : allocates and holds token of vulkan buffer objects. BufferEvents : stores all GPU operations that are deferred to be executed on a command buffer. BufferMemory : acts as an entry point for memory allocation and read/write event push. GraphicsHeap : stores token of graphics objects. GraphicsAllocator : allocates abstracted graphics objects. GraphicsBinder : uses graphics objects to execute draw commands. On initialisation, the GPU systems creates two command buffer objects that are responsible of oredring the GPU to execute draw operations or buffer copy operations. Before the start of the frame, these command buffers are flushed from previous commands. At the end of the frame, these command buffers are submitted in the following order : Transfer command buffer : responsible for buffer copy operations and texture layout transition. Graphics command buffer : responsible for binding graphics objects and draw vertices.","title":"Architecture"},{"location":"gpu/#gpu-memory-allocation","text":"The GPU memory allocation is done by allocating one or more huge chunks of memory on the GPU. Any GPU allocation or deallocation works with a slice of memory of the huge chunk. Memory requirements such as size and alignment is provided by the vulkan API. From these constraint, we manually identify and cut a slice of memory from the GPUHeap. Every heap has it's own memory type defined by the the types of memory requested.","title":"GPU memory allocation"},{"location":"gpu/#buffer","text":"A Buffer is a general purpose memory (like if you allocate memory from CPU). A buffer can be of two type : _Host means that the memory pointer can be directly mapped and visible from CPU. The memory is still allocated on the GPU but reading from it may be less efficient. _GPU means that the memory pointer cannot be visible from CPU. In order to read/write to it, we must create a temporary Host buffer and execute command to transfer data from/to the GPU. All buffer allocations are instant. Ask vulkan for memory requirements. Cut a memory from an already allocated buffer. BufferHost read/write are instantaneous because their memory type corresponds to a host heap chunk that has already been mapped. BufferGPU read/write have an additional level of indirection as a temporary Host buffer must be created and a gpu operation must be registered to a command buffer.","title":"Buffer"},{"location":"gpu/#image","text":"An Image is allocated the same way as a Buffer. Instead of passing a size in bytes, we use an image format object. struct ImageFormat { VkImageAspectFlags imageAspect; VkImageType imageType; ImageUsageFlag imageUsage; VkFormat format; v3ui extent; uint32 mipLevels; uint32 arrayLayers; VkSampleCountFlagBits samples; }; WARNING : mipLevels and arrayLayers are not supported yet. The vulkan api let the user manage an internal state of an image called ImageLayout. It acts as a flag to indicates what operations are allowed on the image. The imageUsage flag indicates where this image will be used (as a shader parameter, or as the target of a render pass) . This flags is the only parameter used to set the underlying image layout. Because the vulkan API needs a specific ImageLayout value when the image is being read or written to, every operations on image must be deferred to execute layout transition before and after.","title":"Image"},{"location":"gpu/#bufferevents-step","text":"The BufferEvents stores all deferred GPU buffer read/write and texture copy events. These events are consumed and the beginning of a frame by the transfer command buffer. Events are consumed in the following order : Image allocation event to execute image layout transition to it's target layout. Read/Write to BufferGPU. Read/Write to ImageGPU. WARNING : It is very important that image host and gpu allocation events are processed before image copy operations because further events assume that the image layout of the image is the targetted one.","title":"BufferEvents step"},{"location":"gpu/#image-allocation","text":"When an image is allocated, it's image layout is undefined. This events execute image layout transition based on the image imageUsage. ImageLayout transition from unknown state to desired imageUsage.","title":"Image allocation"},{"location":"gpu/#readwrite-to-buffergpu","text":"Push copy commands to the temporary buffer (as decribed in the buffer section )","title":"Read/Write to BufferGPU"},{"location":"gpu/#readwrite-to-imagegpu","text":"ImageLayout transition from desired imageUsage to transfert_src or transfert_dst depending on the operation. Copy command. ImageLayout transition from transfert_src or transfert_dst to desired imageUsage.","title":"Read/Write to ImageGPU"},{"location":"gpu/#graphics-abstraction","text":"All graphics abstraction objects describe how a draw command is performed. Allocation of any graphics object is done by having a reference to the BufferMemory object because they can cause buffer or image allocation. Graphics abstraction is a layer on top of the GPU memory layer. There is no depedencies between all these objects. This choice has been made to not enforce any hierarchy. The dependency between objects is ensured by the GraphicsBinding. TextureGPU: A TextureGPU is an Image with a description of which mip map or arraylayer is selected. GraphicsPass: The GraphicsPass is the render texture attachments that will be used for drawing. Texture attachment supported are color attachment and depth attachment. Shader: A Shader is a program that is executed against a GraphicsPass and a set of ShaderParameters. On allocation, a shader is configured to decide wether ztest and zwrite is perfored. ShaderModule: A ShaderModule is the compiled small unit of (vertex|fragment) shader pass executed by the Shader. ShaderLayout: The ShaderLayout indicate the format of all parameters of the Shader (including vertex format). It can be seen as the Reflection data of a Shader. ShaderParameter: A ShaderParameter is a buffer or image that is binded at a certain location of the shader to be used by the program. ShaderParameters can be UniformHost, UniformGPU or TextureGPU. Material: A Material is an array of ShaderParameters.","title":"Graphics abstraction"},{"location":"gpu/#graphics-binding","text":"The graphics binding object allows to notify to the GPU all data needed to perform a draw call. Binding draw commands are sended to the graphics command buffer. A specific bindind order must be respected as validation is performed for every binding. Once an object has been binded, it will still be binded until another one takes it's place. This means that we don't have to re-bind the GraphicsPass or the Shader when we bind another set of ShaderParameters. ShaderParameters can be binded at any position, they also stay binded at the desired index until another one takes place.","title":"Graphics binding"},{"location":"gpu/#presentation","text":"The presentation is a direct usage of the GraphicsBinding. The presentation layer consists of a SwapChain render the input render texture to a present texture. Present textures are allocated internally by the vulkan API by providing a native handle of the window. The SwapChain allocates all GraphicsObjects necessary for drawing the render texture to a present texture. The presentation module is optional, it is up to the consumer to decide whether or not to allocate one and include it the the GraphicsBinding loop. Input : Compiled image quad blit shader module. Already allocated render texture.","title":"Presentation"},{"location":"gpu/#window-resize-event","text":"When the native window is resized internal present textures are reallocated to fit the window dimensions.","title":"Window resize event"},{"location":"render/","text":"The Render module is the 3D renderer of the engine. It registers all graphics objects and organize them in a hierarchy to call GPU graphics bindings against them. The render module creates an internal 2D render target texture and draw the hierachy to it every frame. Architecture The render module is composed of : ColorStep : responsible of the graphics passes supported by the module. D3RendererHeap : holds values of the render hierarchy. D3RendererAllocator : ensure the coherence of the render hierarchy (links between graphics objects). D3RendererEvents : acts as a buffer that store references of all renderable objects that will update it's model matrix. Data model * RenderableObject * Mesh * ShaderUniformBufferHostParameter (model) * Mesh * BufferGPU (vertices_buffer) * BufferGPU (indices_buffer) * ShaderIndex * Shader * ShaderLayout (ShaderIndex)(1)--(0..*)(Material)(1)--(0..*)(RenderableObject) (RenderableObject)(1)--(1)(Mesh) Mesh: Holds reference to a vertex and index GPU buffer. It is up to the render module consumer to define the vertex buffer format. It must match with the shader vertex input. By default, mesh buffers are GPU allocated because we suppose that their vamue won't be modified often. RenderableObject: The renderable object is the representation of an object in 3D space with it's shape. It holds a reference to a Mesh and a model matrix. The model matrix is alaways host shader parameter because it's value is subject to change often. Camera: The camera is from where the whole hierarchy is rendered. WARNING : only one instance of camera can be instantiated for now. ShaderIndex: A shader index is a Shader with a layout and an execution order. Render hierarchy Every frame, the render hierarchy is binded to a GraphicsBinder by following an order : This hierarchy impose that global buffer are binded before everything else and that the model buffer is binded at the very end. This contraint is translated in the shader source code : struct Camera { mat4 view; mat4 projection; }; layout(set = 0, binding = 0) uniform camera { Camera cam; }; // insert all material buffer or samplers layout(set = END, binding = 0) uniform model { mat4 mod; }; Shader ordering ShaderIndex inside the hierarchy are ordered by their execution order. This will come useful when we want to add transparency pass for exemple. Model matrix update Once a RenderableObject has been allocated, consumers of the render module can notify the renderer that an object has moved (pos, rot, scale) by sending a ModelUpdateEvent. When consumed, the ModelUpdateEvent will update the model buffer by the inputted matrix.","title":"Render"},{"location":"render/#architecture","text":"The render module is composed of : ColorStep : responsible of the graphics passes supported by the module. D3RendererHeap : holds values of the render hierarchy. D3RendererAllocator : ensure the coherence of the render hierarchy (links between graphics objects). D3RendererEvents : acts as a buffer that store references of all renderable objects that will update it's model matrix.","title":"Architecture"},{"location":"render/#data-model","text":"* RenderableObject * Mesh * ShaderUniformBufferHostParameter (model) * Mesh * BufferGPU (vertices_buffer) * BufferGPU (indices_buffer) * ShaderIndex * Shader * ShaderLayout (ShaderIndex)(1)--(0..*)(Material)(1)--(0..*)(RenderableObject) (RenderableObject)(1)--(1)(Mesh) Mesh: Holds reference to a vertex and index GPU buffer. It is up to the render module consumer to define the vertex buffer format. It must match with the shader vertex input. By default, mesh buffers are GPU allocated because we suppose that their vamue won't be modified often. RenderableObject: The renderable object is the representation of an object in 3D space with it's shape. It holds a reference to a Mesh and a model matrix. The model matrix is alaways host shader parameter because it's value is subject to change often. Camera: The camera is from where the whole hierarchy is rendered. WARNING : only one instance of camera can be instantiated for now. ShaderIndex: A shader index is a Shader with a layout and an execution order.","title":"Data model"},{"location":"render/#render-hierarchy","text":"Every frame, the render hierarchy is binded to a GraphicsBinder by following an order : This hierarchy impose that global buffer are binded before everything else and that the model buffer is binded at the very end. This contraint is translated in the shader source code : struct Camera { mat4 view; mat4 projection; }; layout(set = 0, binding = 0) uniform camera { Camera cam; }; // insert all material buffer or samplers layout(set = END, binding = 0) uniform model { mat4 mod; };","title":"Render hierarchy"},{"location":"render/#shader-ordering","text":"ShaderIndex inside the hierarchy are ordered by their execution order. This will come useful when we want to add transparency pass for exemple.","title":"Shader ordering"},{"location":"render/#model-matrix-update","text":"Once a RenderableObject has been allocated, consumers of the render module can notify the renderer that an object has moved (pos, rot, scale) by sending a ModelUpdateEvent. When consumed, the ModelUpdateEvent will update the model buffer by the inputted matrix.","title":"Model matrix update"},{"location":"ressource/","text":"A Ressource is an instanciated object that load data from the the asset database to allocate a system internal object. The ressource object doesn't have any logic, it simply holds references to the allocated internal object. Architecture Every ressource is associated to an allocation unit. This allocation unit is responsible of handling all allocation and deallocation inputs. If the criteria is met, it stores the event in a buffer that is later consumed by the main loop. Allocation/Deallocation When an allocation is requested, the allocation unit generate a ressource token that is returned to the caller. Also, an internal allocation event is generated. The consumer can retrieve the allocated ressource by providing the returned token. When a deallocation is requested, the allocation unit generate a deallocation event. The token is invalid when the event is consumed and that the ressource has been freed. The same ressource can be allocated multiple times. When that happens, the same ressource token is returned and the usage counter in incremented by one. Deallocation request make the counter decready by one. As soon as the counter reaches zero, the deallocation event is generated. Allocation modes The ressource allocation input can be provided by two ways: Requested to the database: If the ressource input is requested to the database, the caller provide the asset path used by the database to retrieve the asset. Provided inline: If the ressource input is provided inline, the caller provide the same data as if it were retrieved by the database. Allocation events are processed in the following order for a single allocation unit : Ressource identification All ressources are associated to an internal id. When the ressource input is provided inline, the ressource id is given by the caller. When the ressource input is provided by the database, the ressource id is computed by the hash of the asset path. Ressource dependencies Ressources can be linked together (for example, a Mateial is linked to Shader) introducing an allocation and deallocation execution order. A goal of the allocation units is to handle the recursive allocation/deallocation of linked internal system objects, to that the internal systems can blindfully execute requests from the allocation unit. If ressource A needs ressource B to work, then the allocation order will be : (B) -> (A). And the deallocation order : ( A) -> (B). When the ressource allocation input is provided inline, it is up to the caller to provide input for the requested ressource and it's dependencies. When the ressource allocation input is provided by the database, then an additional asset database request is performed to retrieve asset id dependencies.","title":"Ressource"},{"location":"ressource/#architecture","text":"Every ressource is associated to an allocation unit. This allocation unit is responsible of handling all allocation and deallocation inputs. If the criteria is met, it stores the event in a buffer that is later consumed by the main loop.","title":"Architecture"},{"location":"ressource/#allocationdeallocation","text":"When an allocation is requested, the allocation unit generate a ressource token that is returned to the caller. Also, an internal allocation event is generated. The consumer can retrieve the allocated ressource by providing the returned token. When a deallocation is requested, the allocation unit generate a deallocation event. The token is invalid when the event is consumed and that the ressource has been freed. The same ressource can be allocated multiple times. When that happens, the same ressource token is returned and the usage counter in incremented by one. Deallocation request make the counter decready by one. As soon as the counter reaches zero, the deallocation event is generated.","title":"Allocation/Deallocation"},{"location":"ressource/#allocation-modes","text":"The ressource allocation input can be provided by two ways: Requested to the database: If the ressource input is requested to the database, the caller provide the asset path used by the database to retrieve the asset. Provided inline: If the ressource input is provided inline, the caller provide the same data as if it were retrieved by the database. Allocation events are processed in the following order for a single allocation unit :","title":"Allocation modes"},{"location":"ressource/#ressource-identification","text":"All ressources are associated to an internal id. When the ressource input is provided inline, the ressource id is given by the caller. When the ressource input is provided by the database, the ressource id is computed by the hash of the asset path.","title":"Ressource identification"},{"location":"ressource/#ressource-dependencies","text":"Ressources can be linked together (for example, a Mateial is linked to Shader) introducing an allocation and deallocation execution order. A goal of the allocation units is to handle the recursive allocation/deallocation of linked internal system objects, to that the internal systems can blindfully execute requests from the allocation unit. If ressource A needs ressource B to work, then the allocation order will be : (B) -> (A). And the deallocation order : ( A) -> (B). When the ressource allocation input is provided inline, it is up to the caller to provide input for the requested ressource and it's dependencies. When the ressource allocation input is provided by the database, then an additional asset database request is performed to retrieve asset id dependencies.","title":"Ressource dependencies"},{"location":"scene/","text":"A node hierarchy where every node can have components. The node hierarchy allows to position points in 3D space where parent movement influence the child position. Components are functionality attached to the node that communicate with internal systems via the scene middleware. Architecture Node: a point int 3D space. SceneTree: the hierachical view of nodes. All node movement must be done through the SceneTree. Component: a component is a typed external object associated to a node. Scene: an object that link nodes to components. It acts as an interface of the scene tree. Scene hierarchical update The node is composed of a local transform (position, rotation, scale) and a local to world matrix. When updating a node transform, what we change is the local transform. The local to world matrix is recalculated on the fly, only when needed. THe local to world matrix value is cached until the transform change again. Because nodes are organized in a tree, the parent movement affect the child position. When a node parent position is set, this change is propagated recursively into the tree. This propagation is done instantaneously. When a node transform has changed, the internal state of the node indicates that this frame, the node has changed. This state can be used by middleware to check if a node has moved or not. WARNING: The state of the node is cleared every frame. Component allocation The component is a structure that contains a type and an external object token. When we want to add a component to a node, it's external ressource has already been allocated by the scene middleware (or at least, a token has been generated). So, we provide this token to the node component allocation. Component deallocation events Because component deallocation can be triggered manually by the user logic on indirectly by removing a node, component deallocation events are stored to an event buffer. From the point of view of the scene, we have no idea of what is the external component object allocated or what is it's purpose. So we need to send notifications when the component is removed. To do so, the component deallocation event buffer can be consumed to execute functions accordingly to the component type. WARNING : The component deallocation event buffer is cleared at the end of every frame. If events are not consumed before that, then events will be lost.","title":"Scene"},{"location":"scene/#architecture","text":"Node: a point int 3D space. SceneTree: the hierachical view of nodes. All node movement must be done through the SceneTree. Component: a component is a typed external object associated to a node. Scene: an object that link nodes to components. It acts as an interface of the scene tree.","title":"Architecture"},{"location":"scene/#scene-hierarchical-update","text":"The node is composed of a local transform (position, rotation, scale) and a local to world matrix. When updating a node transform, what we change is the local transform. The local to world matrix is recalculated on the fly, only when needed. THe local to world matrix value is cached until the transform change again. Because nodes are organized in a tree, the parent movement affect the child position. When a node parent position is set, this change is propagated recursively into the tree. This propagation is done instantaneously. When a node transform has changed, the internal state of the node indicates that this frame, the node has changed. This state can be used by middleware to check if a node has moved or not. WARNING: The state of the node is cleared every frame.","title":"Scene hierarchical update"},{"location":"scene/#component-allocation","text":"The component is a structure that contains a type and an external object token. When we want to add a component to a node, it's external ressource has already been allocated by the scene middleware (or at least, a token has been generated). So, we provide this token to the node component allocation.","title":"Component allocation"},{"location":"scene/#component-deallocation-events","text":"Because component deallocation can be triggered manually by the user logic on indirectly by removing a node, component deallocation events are stored to an event buffer. From the point of view of the scene, we have no idea of what is the external component object allocated or what is it's purpose. So we need to send notifications when the component is removed. To do so, the component deallocation event buffer can be consumed to execute functions accordingly to the component type. WARNING : The component deallocation event buffer is cleared at the end of every frame. If events are not consumed before that, then events will be lost.","title":"Component deallocation events"},{"location":"scene_middleware/","text":"The SceneMiddleware is the indirection layer between the Scene and the internal Systems. When a component is added to a node, the component internal ressource is allocated from one of the scene middlewares. Scene middlewares also act as interface for scene component deallocation event. The scene middlewares can consume the state of the node to tell whether a specific node has changed this frame, to notify internal systems. Architecture SceneMiddleware: holds functions for component deallocation XXX Component Unit: responsible of deferred allocation of component XXX Middleware: the system that communicate node events to internal systems Component objects allocation Component objects are allocated by the user by using the same deferred allocation mechanism as the ressrouces. However, every component objects has it's id that is generated by the unit. WARNING : Because component objects may depend of some ressources, ressources allocation must be exectued before. The same logic goes for deallocation. Scene node event push Middlewares hold an array of structure that links the node to the component object. When necessary, the middleware can iterate over this array to check the state of the node. If criterias are met (for example: the node has moved during the last frame), then a notification can be sended to the internal system.","title":"Scene Middleware"},{"location":"scene_middleware/#architecture","text":"SceneMiddleware: holds functions for component deallocation XXX Component Unit: responsible of deferred allocation of component XXX Middleware: the system that communicate node events to internal systems","title":"Architecture"},{"location":"scene_middleware/#component-objects-allocation","text":"Component objects are allocated by the user by using the same deferred allocation mechanism as the ressrouces. However, every component objects has it's id that is generated by the unit. WARNING : Because component objects may depend of some ressources, ressources allocation must be exectued before. The same logic goes for deallocation.","title":"Component objects allocation"},{"location":"scene_middleware/#scene-node-event-push","text":"Middlewares hold an array of structure that links the node to the component object. When necessary, the middleware can iterate over this array to check the state of the node. If criterias are met (for example: the node has moved during the last frame), then a notification can be sended to the internal system.","title":"Scene node event push"}]}