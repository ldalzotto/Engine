<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>GPU - From Scratch</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <link href="../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Architecture", url: "#_top", children: [
          ]},
          {title: "GPU memory allocation", url: "#gpu-memory-allocation", children: [
              {title: "Buffer", url: "#buffer" },
              {title: "Image", url: "#image" },
              {title: "BufferEvents step", url: "#bufferevents-step" },
          ]},
          {title: "Graphics abstraction", url: "#graphics-abstraction", children: [
          ]},
          {title: "Graphics binding", url: "#graphics-binding", children: [
          ]},
          {title: "Presentation", url: "#presentation", children: [
              {title: "Window resize event", url: "#window-resize-event" },
          ]},
        ];

    </script>
    <script src="../js/base.js"></script>
      <script src="../js/custom.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../render/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../render/" class="btn btn-xs btn-link">
        Render
      </a>
    </div>
    
  </div>

    

    <p>The GPU module is responsible for :</p>
<ul>
<li>Providing convenient systems to allocate, free and write to GPU memory chunks.</li>
<li>Deferring commands that needs synchronization with the gpu.</li>
<li>Abstracting graphics objects such as Shader, Material ...</li>
</ul>
<h1 id="architecture">Architecture</h1>
<p><svg-inline src="./gpu_arch.svg"></svg-inline></p>
<p>The GPU module is composed of :</p>
<ul>
<li>GPUHeap : allocates a huge chunk of GPU memory and cut a slice into it based on vulkan constraint.</li>
<li>BufferAllocator : allocates and holds token of vulkan buffer objects.</li>
<li>BufferEvents : stores all GPU operations that are deferred to be executed on a command buffer.</li>
<li>BufferMemory : acts as an entry point for memory allocation and read/write event push.</li>
<li>GraphicsHeap : stores token of graphics objects.</li>
<li>GraphicsAllocator : allocates abstracted graphics objects.</li>
<li>GraphicsBinder : uses graphics objects to execute draw commands.</li>
</ul>
<p>On initialization, the GPU systems creates two command buffer objects that are responsible for ordering the GPU to
execute draw operations or buffer copy operations.</p>
<p>Before the start of the frame, these command buffers are flushed from previous commands. At the end of the frame, these
command buffers are submitted in the following order :</p>
<ol>
<li>Transfer command buffer : responsible for buffer copy operations and texture layout transition.</li>
<li>Graphics command buffer : responsible for binding graphics objects and draw vertices.</li>
</ol>
<h1 id="gpu-memory-allocation">GPU memory allocation</h1>
<p>The GPU memory allocation is done by allocating one or more huge chunks of memory on the GPU. Any GPU allocation or
deallocation works with a slice of memory of the huge chunk.</p>
<p>Memory requirements such as size and alignment is provided by the vulkan API. From these constraints, we manually
identify and cut a slice of memory from the GPUHeap. Every heap has its own memory type defined by the types of
memory requested.</p>
<h2 id="buffer">Buffer</h2>
<p>A Buffer is a general purpose memory (like if you allocate memory from CPU). A buffer can be of two type :</p>
<ul>
<li>_Host means that the memory pointer can be directly mapped and visible from CPU. The memory is still allocated on the
  GPU but reading from it may be less efficient.</li>
<li>_GPU means that the memory pointer cannot be visible from CPU. In order to read/write to it, we must create a
  temporary Host buffer and execute command to transfer data from/to the GPU.</li>
</ul>
<p>All buffer allocations are instant.</p>
<ol>
<li>Ask vulkan for memory requirements.</li>
<li>Cut a memory from an already allocated buffer.</li>
</ol>
<p>BufferHost read/write are instantaneous because their memory type corresponds to a host heap chunk that has already been
mapped.</p>
<p>BufferGPU read/write have an additional level of indirection as a temporary Host buffer must be created and a gpu
operation must be registered to a command buffer.</p>
<h2 id="image">Image</h2>
<p>An Image is allocated the same way as a Buffer. Instead of passing a size in bytes, we use an image format object.</p>
<pre><code>struct ImageFormat
{
    VkImageAspectFlags imageAspect;
    VkImageType imageType;
    ImageUsageFlag imageUsage;
    VkFormat format;
    v3ui extent;
    uint32 mipLevels;
    uint32 arrayLayers;
    VkSampleCountFlagBits samples;
};
</code></pre>
<blockquote>
<p><strong>WARNING</strong>: mipLevels and arrayLayers are not supported yet.</p>
</blockquote>
<p>The vulkan api let the user manage an internal state of an image called ImageLayout. It acts as a flag to indicates what
operations are allowed on the image.</p>
<p>The image usage flag indicates where this image will be used (as a shader parameter, or as the target of a render pass)
. <br/>
This flags is the only parameter used to set the underlying image layout.</p>
<p>Because the vulkan API needs a specific image layout value when the image is being read or written to, every operation
on image must be deferred to execute layout transition before and after.</p>
<h2 id="bufferevents-step">BufferEvents step</h2>
<p>The BufferEvents stores all deferred GPU buffer read/write and texture copy events. <br/>
These events are consumed and the beginning of a frame by the transfer command buffer. <br/>
Events are consumed in the following order :</p>
<ol>
<li>Image allocation event to execute image layout transition to it's target layout.</li>
<li>Read/Write to BufferGPU.</li>
<li>Read/Write to ImageGPU.</li>
</ol>
<blockquote>
<p><strong>WARNING</strong>: It is very important that image host and gpu allocation events are processed before image copy operations because further events assume that the image layout of the image is the targetted one.</p>
</blockquote>
<h3 id="image-allocation">Image allocation</h3>
<p>When an image is allocated, its image layout is undefined. These events execute image layout transition based on the
image imageUsage.</p>
<ol>
<li>ImageLayout transition from unknown state to desired imageUsage.</li>
</ol>
<h3 id="readwrite-to-buffergpu">Read/Write to BufferGPU</h3>
<ol>
<li>Push copy commands to the temporary buffer (as described in the <a href="#buffer">buffer section</a>)</li>
</ol>
<h3 id="readwrite-to-imagegpu">Read/Write to ImageGPU</h3>
<ol>
<li>Image layout transition from desired image usage to transfert_src or transfert_dst depending on the operation.</li>
<li>Copy command.</li>
<li>Image layout transition from transfert_src or transfert_dst to desired image usage.</li>
</ol>
<h1 id="graphics-abstraction">Graphics abstraction</h1>
<p>All graphics abstraction objects describe how a draw command is performed. Allocation of any graphics object is done by
having a reference to the buffer memory object because they can cause buffer or image allocation. <br/>
Graphics abstraction is a layer on top of the GPU memory layer.</p>
<p>There is no dependencies between all these objects. This choice has been made to not enforce any hierarchy. The
dependency between objects is ensured by the graphics binding.</p>
<p><strong>TextureGPU:</strong></p>
<p>A TextureGPU is an Image with a description of which mip map or array layer is selected.</p>
<p><strong>GraphicsPass:</strong></p>
<p>The GraphicsPass is the render texture attachments that will be used for drawing. <br/>
Texture attachment supported are colour attachment and depth attachment.</p>
<p><strong>Shader:</strong></p>
<p>A Shader is a program that is executed against a GraphicsPass and a set of ShaderParameters. <br/>
On allocation, a shader is configured to decide whether ztest and zwrite is perfored.</p>
<p><strong>ShaderModule:</strong></p>
<p>A ShaderModule is the compiled small unit of (vertex|fragment) shader pass executed by the Shader.</p>
<p><strong>ShaderLayout:</strong></p>
<p>The ShaderLayout indicate the format of all parameters of the Shader (including vertex format). It can be seen as the
Reflection data of a Shader.</p>
<p><strong>ShaderParameter:</strong></p>
<p>A ShaderParameter is a buffer or image that is bound at a certain location of the shader to be used by the
program. <br/>
ShaderParameters can be UniformHost, UniformGPU or TextureGPU.</p>
<p><strong>Material:</strong></p>
<p>A Material is an array of ShaderParameters.</p>
<h1 id="graphics-binding">Graphics binding</h1>
<p>The graphics binding object allows notifying to the GPU all data needed to perform a draw call. <br/>
Binding draw commands are sent to the graphics command buffer. A specific binding order must be respected as
validation is performed for every binding. <br/></p>
<p><svg-inline src="./gpu_bind_order.svg"></svg-inline></p>
<p>Once an object has been bound, it will still be bound until another one takes its place. This means that we don't
have to re-bind the graphics pass or the Shader when we bind another set of ShaderParameters. <br/>
ShaderParameters can be bound at any position, they also stay bound at the desired index until another one takes
place.</p>
<h1 id="presentation">Presentation</h1>
<p>The presentation is a direct usage of the GraphicsBinding. The presentation layer consists of a SwapChain render the
input render texture to a present texture. <br/>
Present textures are allocated internally by the vulkan API by providing a native handle of the window. The SwapChain
allocates all GraphicsObjects necessary for drawing the render texture to a present texture. <br/>
The presentation module is optional, it is up to the consumer to decide whether or not to allocate one and include it
the GraphicsBinding loop.</p>
<p><strong>Input :</strong></p>
<ul>
<li>Compiled image quad blit shader module.</li>
<li>Already allocated render texture.</li>
</ul>
<h2 id="window-resize-event">Window resize event</h2>
<p>When the native window is resized internal present textures are reallocated to fit the window dimensions.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../render/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../render/" class="btn btn-xs btn-link">
        Render
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>